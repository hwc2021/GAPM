package GSAT;
#updated at Nov 22th, 2022: fixed a bug related to the params in example.conf

#参考circos布局

#功能分成graphfilt,graphmap,graphcorr,graphsimply等选项，不可联用；pipe分成graph-short，graph-long，graph-sim，graph-corr等选项即可，可联用。功能与pipeline不可同时设定
#支持参数放进config文件里；功能中config文件为可选项；pipeline要求必须有config文件。
#统一放入文件夹中。此外，不同pipeline放入不同子文件夹。

=pod

=head1 NAME

GSAT - Graph-based Sequence Assembly Toolkit

=head1 SYNOPSIS

    gsat <command> [options]

    Commands:
    -- Functions
       graphFilt            filter the assembly graph with different params
       graphMap             conduct graph mapping to detect mapped paths in a graph for query sequence
       graphCorr            correct the sequences in a graph by using long reads. HIFI reads is recommanded.
       graphSimplify        simplify the graph based on supported mapped paths of long reads.
       rmOverlap            remove the overlaping regions from a graph

    -- Pipelines
       graphShort           generate a Organelle Graph from a raw graph of de novo assembly
       graphLong            generate a Mitochondrial Rough Graph from a OG
       graphSimplification  generate a Mitochondrial Rough Master Graph from a MRG
       graphCorrection      generate a Mitochondrial Master Graph from a MRMG

    -- Information
       help                 print a brief help information
       man                  print a complete help document
       version              print the version information

=head1 VERSION

GSAT version 1.00 (2022-07-14)

=head1 USAGE

 Usage

=head1 graphFilt

    Usage:   gsat graphFilt [options]

    Global params:
    -pt|-p             filter the plastid-specific contigs. Not compatiable with -nuc.*
    -nuc|-n            filter the nuclear-specific contigs. Not compatiable with -pt.*
    -gfaFile|-g [str]  the input graph file.*
    -out|-o [str]      the name prefix of the output files.

    Pt-filtering params:
    -mapFile [str]     the mapped paths file generated by graph mapping.*
    -minPathNo [int]   the min number of supported paths for remaining a link.*
    -minEnd [int]      the end contig with a length shorter than this value will be filtered.*
    -rmBubbPt          remove the pt-like contig from a bubble. Be careful with this option. [off]

    Nuc-filtering params:
    -minDep1 [int]     the min depth allowed for a remained contig longer than 500bp.*
    -minDep2 [int]     the min depth allowed for a remained contig longer than 1000bp.*
    -rmSep             remove the seperate ctg with no link to others or not. [off]

    Note: the * denoted a required option. 

=head1 graphMap

    Usage:   gsat graphMap [options]

    -align|-a                 Conduct graph mapping of reads vs the graph (require -r and -g options). [off]*
    -readFile|-r [str]        A Pacbio / Nanopore read file in fasta format. NOT available if -a is off.*
    -gfaFile|-g [str]         The input graph file.*
    -blast7File|-b [str]      Calculate the mapped paths from a blastn result file. NOT available if -a|-p is applied.*
    -pafFile|-p [str]         Calculate the mapped paths from a minimap2 result file. NOT available if -a|-b is applied.*
    -minRead [int]            The min length (bp) of selected reads. [1000]
    -maxOffset1 [int]         The max offset between the ends of contigs in alignments, regarding the overlaps of contigs. [10]
                              The real range of offset is from 1-K-offset to 1-K+offset. Not compatible with --maxOffset2.
    -maxOffset2 [int]         The max offset between the ends of contigs in alignments, ignoring the overlaps of contigs. [off]
                              The real range of offset is from 0-offset to 0+offset. Not compatible with --maxOffset1.
    -maxCombDis [int]         The max distances allowed for combining two alignments. [15]
    -maxEdgeSize1 [int]       The max gap size allowed for the alignment at the edge of reads. [60]
    -maxEdgeSize2 [int]       The max gap size allowed for the alignment at the edge of contigs. [10]
    -maxBounderRatio [float]  The max ratio allowed for the bounder size which covered the full length of a contig. [0.1]
    -maxIdenGap [float]       The max difference allowed for remained an alternative alignment (path)
                              when compared with to the identity of the best alignment (path). [1]
                              Caution: It is still a beta method that is not recommanded to use until now.
    -minIden [float]          The min identity allowed for use an alignment (in b7 and paf file). [0.85]
    -minCovofRead [float]     The min coverage allowed in the alignment for use a read (in b7 and paf file). [0.9]
    -minCovbyPath [float]     The min coverage to the read allowed for outputting a path. [0.9]
    -out|-o [str]             The name prefix of output files.
    -strictBub                Bubbles were retained only when all members were mapped to the read with exactly the same
                              start and end positions. [on]
    -depth|-d                 Calculate the depth of passed reads on the contigs. [off]
    -calDepth|-cd             Calculate the depth (like -d) directly from previous results (require -o and -g options). [off]
    -filterPaths|-f           Further filtering the previous results when apply the -cd option. [off]
                              However, only -minRead and -minCovbyPath options are available for now.
    -minimap2 [str]           Use minimap2 to map reads to the long contigs, rather than use blastn. [off]
                              The read type should be specified here such as hifi, clr, ont.

    Note: the * denoted a required option. 

=head1 graphCorr

    Usage:   gsat graphCorr [options]

    -readFile|-r [str]       A Pacbio / Nanopore read file in fasta format.* 
    -gfaFile|-g  [str]       The file of genome assembly in gfa format.\n";*
    -pathFile|-p [str]       The mapped paths file generated by GraphMap module (module version >= 1.51).*
    -minReadProp|-m [float]  The min proportion of supported reads to confirm a base correction.
    -out|-o [str]            The name prefix of output files.\n";

    Note: the * denoted a required option.

=head1 graphSimplify

    Usage:   gsat graphSimplify [options]

    -gfaFile|-g [str]  the input graph file.*
    -mapFile [str]     the mapped paths file generated by graph mapping.*
    -minPathNo [int]   the min number of supported paths for remaining a link.*
    -minEnd [int]      the end contig with a length shorter than this value will be filtered.
    -out|-o [str]      the name prefix of output files.\n";

    Note: the * denoted a required option.

=head1 rmOverlap

    Usage:   gsat rmOverlap [options]

    -gfaFile|-g [str]  the input graph file.*
    -out|-o [str]      the name prefix of output files.\n";

    Note: the * denoted a required option.

=head1 graphShort

    Usage:   gsat graphShort [options]

    -conf [str]        the config file.*
    -cpu [int]         number of cpu cores which could be used for the pipeline.

    Note: the * denoted a required option.

=head1 graphLong

    Usage:   gsat graphLong [options]

    -conf [str]        the config file.*

    Note: the * denoted a required option.

=head1 graphSimplification

    Usage:   gsat graphSimplification [options]

    -conf [str]        the config file.*

    Note: the * denoted a required option.

=head1 graphCorrection

    Usage:   gsat graphCorrection [options]

    -conf [str]        the config file.*

    Note: the * denoted a required option.

=cut

use strict;
use warnings;
use FindBin;
use File::Basename;
use Getopt::Long;
use Getopt::Long qw(GetOptionsFromArray);
use Pod::Usage;
use Pod::Find qw(pod_where);
use lib "$FindBin::RealBin";
use lib "$FindBin::RealBin/../lib";
use lib "$FindBin::RealBin/lib";

require GSAT::graphFilterPt;
require GSAT::graphFilterNuc;
require GSAT::graphMapper;
require GSAT::graphCorrector;
require GSAT::graphSimply;
require GSAT::rmOverlap;

sub gsatRun{
   our ($proc,$opt)=@_;
   if($proc =~ /^graphFilt$/i){
      my ($pt,$nuc,$gfa,$map,$outP,$minPath,$minEnd,$rmPt,$minD1,$minD2,$rmSep);
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(graphFilt) ])if @{$opt} == 0;
      GetOptionsFromArray($opt,
        'pt'           => \$pt,
        'nuc'          => \$nuc,
        'gfaFile=s'    => \$gfa,
        'mapFile=s'    => \$map,
        'out=s'        => \$outP,
        'minPathNo=i'  => \$minPath,
        'minEnd=i'     => \$minEnd,
        'rmBubbPt'     => \$rmPt,
        'minDep1=i'    => \$minD1,
        'minDep2=i'    => \$minD2,
        'rmSep'        => \$rmSep,
      );
      my $rstat= defined($rmPt) ? 'T':'F';
      graphFilterPt::filterPt($gfa,$map,$minPath,$minEnd,$rstat,'T',$outP) if defined($pt);
      my $rsstat= defined($rmSep) ? 'T':'F';
      graphFilterNuc::filterNuc($gfa,$minD1,$minD2,$rsstat,$outP) if defined($nuc);
   }
   elsif($proc =~ /^graphMap$/i){
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(graphMap) ])if @{$opt} == 0;
      graphMapper::gmap($opt);#done
   }
   elsif($proc =~ /^graphCorr$/i){
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(graphCorr) ])if @{$opt} == 0;
      graphCorrector::grapCorr($opt);#done
   }
   elsif($proc =~ /^graphSimplify$/i){
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(graphSimplify) ])if @{$opt} == 0;
      my ($gfa,$map,$outP,$minPath,$minEnd);
      GetOptionsFromArray($opt,
        'gfaFile=s'      => \$gfa,
        'mapFile=s'      => \$map,
        'out=s'          => \$outP,
        'minPathNo=i'    => \$minPath,
        'minEnd=i'       => \$minEnd,
      );
      graphSimply::filterGraph($gfa,$map,$minPath,$minEnd,$outP);#list
   }
   elsif($proc =~ /^rmOverlap$/i){
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(rmOverlap) ])if @{$opt} == 0;
      my ($gfa,$outP);
      GetOptionsFromArray($opt,
        'gfaFile=s'      => \$gfa,
        'out=s'          => \$outP,
      );
      rmOverlap::m0proc($gfa,$outP);#done
   }
   elsif($proc =~ /^graphShort$/i){
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(graphShort) ])if @{$opt} == 0;
      pipeShort($opt);
   }
   elsif($proc =~ /^graphLong$/i){
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(graphLong) ])if @{$opt} == 0;
      pipeLong($opt);
   }
   elsif($proc =~ /^graphSimplification$/i){
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(graphSimplification) ])if @{$opt} == 0;
      pipeSim($opt);
   }
   elsif($proc =~ /^graphCorrection$/i){
      pod2usage(-input => pod_where({-inc => 1}, "GSAT"),-verbose => 99,-sections => [ qw(graphCorrection) ])if @{$opt} == 0;
      pipeCorr($opt);
   }
   else{
      die"Error: Wrong command detected!\n";
   }
}

sub pipeShort{
   my @opts2_1=('r1','r2','maxReadLen','minDep1','minDep2');
   my @opts2_2=('rmSep');
   my @x1=('');
   my @x2=('');
   my $opts3='out';
   my $spades='spades.py';
   my $cpu=2;
   my $confile;
   GetOptionsFromArray($_[0],
        'conf=s'      => \$confile,
        'cpu=i'          => \$cpu,
      );
   my ($c1,$c2,$outp)=readConf($confile,\@opts2_1,\@opts2_2,\@x1,\@x2,$opts3);
   newDir($outp); 
   my @short_opt=split(/ /,$c1);
   my ($r1,$r2,$max_rlen,$minD1,$minD2,$rmSep,$ks);
   GetOptionsFromArray(\@short_opt,
        'r1=s'      => \$r1,
        'r2=s'      => \$r2,
        'maxReadLen=i'   => \$max_rlen,
        'minDep1=i'      => \$minD1,
        'minDep2=i'      => \$minD2,
        'rmSep'          => \$rmSep,
      );
   my $in_gfa=$outp.'/spades/assembly_graph_with_scaffolds.gfa';
   print "Read1: $r1 ; Read2: $r2 ";
   warn "Warning: Please note that the SPAdes is not recommended for large sequencing dataset > 5 gb. You can use a subset instead.\n" if (stat($r1))[7] > 5000000 &&  (stat($r2))[7] > 5000000;
   if($max_rlen >92 && $max_rlen <= 102){
      $ks="-k 21,33,55,71,91";
   }
   elsif($max_rlen > 147 && $max_rlen <= 152){
      $ks="-k 33,55,77,99,121";
   }
   elsif($max_rlen > 100 && $max_rlen <= 150){
      $ks="-k 21,33,55,71,99";
   }
   else{
      $ks="";
   }
   print `$spades --careful -1 $r1 -2 $r2 $ks --cov-cutoff auto -t $cpu -o $outp/spades`;
   #eval {`$spades --careful -1 $r1 -2 $r2 $ks --cov-cutoff auto -t $cpu -o $outp/spades`;};
   die "$@ \n" if $@;
   my $rsstat= defined($rmSep) ? 'T':'F';
   graphFilterNuc::filterNuc($in_gfa,$minD1,$minD2,$rsstat,$outp.'/og');
}

my @opts1_1=('readFile','gfaFile','minRead','maxOffset1','maxOffset2','maxCombDis','maxEdgeSize1','maxEdgeSize2','maxBounderRatio','maxIdenGap','minIden','minCovofRead','minCovbyPath','strictBub','minimap2');
my @opts1_2=('depth');
sub pipeLong{
   my @opts2_1=('gfaFile','minPathNo','minEnd');
   my @opts2_2=('rmBubbPt');
   my $opts3='out';
   my $confile;
   GetOptionsFromArray($_[0],
        'conf=s'      => \$confile,
      );
   my ($c1,$c2,$outp)=readConf($confile,\@opts1_1,\@opts1_2,\@opts2_1,\@opts2_2,$opts3);
   newDir($outp); 
   my @gmap_opt=((split(/ /,$c1)),'-a','-'.$opts3,$outp.'/gmap');
   my @gfp_opt=split(/ /,$c2);
   graphMapper::gmap(\@gmap_opt);
   my $pfile=$outp.'/gmap.mapping.paths';
   my ($gfa,$minPath,$minEnd,$rmPt);
   GetOptionsFromArray(\@gfp_opt,
        'gfaFile=s'    => \$gfa,
        'minPathNo=i'  => \$minPath,
        'minEnd=i'     => \$minEnd,
        'rmBubbPt'     => \$rmPt,
      );
   my $rstat= defined($rmPt) ? 'T':'F';
   graphFilterPt::filterPt($gfa,$pfile,$minPath,$minEnd,$rstat,'T',$outp.'/mrg');
}

sub pipeCorr{
   my @opts2_1=('readFile','gfaFile','minReadProp');
   my @opts2_2=('undef');
   my $opts3='out';
   my $confile;
   GetOptionsFromArray($_[0],
        'conf=s'      => \$confile,
      );
   my ($c1,$c2,$outp)=readConf($confile,\@opts1_1,\@opts1_2,\@opts2_1,\@opts2_2,$opts3);
   newDir($outp); 
   my @gmap_opt=((split(/ /,$c1)),'-a','-'.$opts3,$outp.'/gmap');
   graphMapper::gmap(\@gmap_opt);
   my $pfile=$outp.'/gmap.mapping.paths';
   my @gc_opt=((split(/ /,$c2)),'-'.$opts3,$outp.'/mmg','-pathFile',$pfile);
   graphCorrector::grapCorr(\@gc_opt);
}

sub pipeSim{
   my @opts2_1=('gfaFile','minPathNo','minEnd');
   my @opts2_2=('undef');
   my $opts3='out';
   my $confile;
   GetOptionsFromArray($_[0],
        'conf=s'      => \$confile,
      );
   my ($c1,$c2,$outp)=readConf($confile,\@opts1_1,\@opts1_2,\@opts2_1,\@opts2_2,$opts3);
   newDir($outp); 
   my @gmap_opt=((split(/ /,$c1)),'-a','-'.$opts3,$outp.'/gmap');
   graphMapper::gmap(\@gmap_opt);
   my $pfile=$outp.'/gmap.mapping.paths';
   my @gs_opt=split(/ /,$c2);
   my ($gfa,$minPath,$minEnd);
      GetOptionsFromArray(\@gs_opt,
        'gfaFile=s'      => \$gfa,
        'minPathNo=i'    => \$minPath,
        'minEnd=i'       => \$minEnd,
      );
   graphSimply::filterGraph($gfa,$pfile,$minPath,$minEnd,$outp.'/mrmg');
}

sub readConf{
   my ($inf,$opt1x1,$opt1x2,$opt2x1,$opt2x2,$out)=@_;
   open(CFILE,$inf) || die "Error: Cannot open the config file! \n";
   my @opt1;
   my @opt2;
   foreach (<CFILE>){
      chomp;
      next if /^#|^\s|^$/;
      my ($n,$v)=split(/\s+/);
      push @opt1,$n;
      push @opt2,$v;
   }
   close CFILE;

   my $used1='^'.join('$|^',@{$opt1x1}).'$';
   my $used2='^'.join('$|^',@{$opt2x1}).'$';
   my @opt_a1=map {'-'.$opt1[$_].' '.$opt2[$_]} (grep {$opt2[$_] ne 'off' && $opt1[$_]=~/$used1/} 0..$#opt1);
   my @opt_a2=map {'-'.$opt1[$_].' '.$opt2[$_]} (grep {$opt2[$_] ne 'off' && $opt1[$_]=~/$used2/} 0..$#opt1);
   my ($optsv3)=map {$opt2[$_]} (grep {$opt1[$_]=~/$out/} 0..$#opt1);
   $optsv3 = 'gsat' if length($optsv3) < 1;
   my $usedu1='^'.join('$|^',@{$opt1x2}).'$';
   my $usedu2='^'.join('$|^',@{$opt2x2}).'$';
   my @opt_b1=map {'-'.$opt1[$_]} (grep {$opt1[$_]=~/$usedu1/ && $opt2[$_] eq 'on'} 0..$#opt1);
   my @opt_b2=map {'-'.$opt1[$_]} (grep {$opt1[$_]=~/$usedu2/ && $opt2[$_] eq 'on'} 0..$#opt1);

   return(join(' ',(@opt_a1,@opt_b1)),join(' ',(@opt_a2,@opt_b2)),$optsv3);
}

sub newDir{
   my $outp=shift @_;
   if(-d $outp){
      die"Error: the specified target dir is existed: $outp \n";
   }
   else{
      mkdir($outp) || die "Error: Cannot create the target dir: $outp \n";
   }
}